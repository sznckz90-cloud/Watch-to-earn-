import { useState, useEffect, useCallback } from "react";
import { useAuth } from "@/hooks/useAuth";
import Layout from "@/components/Layout";
import AdWatchingSection from "@/components/AdWatchingSection";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import React from "react";
import { useAdmin } from "@/hooks/useAdmin";
import { useAdFlow } from "@/hooks/useAdFlow";
import { useLocation } from "wouter";
import { SettingsPopup } from "@/components/SettingsPopup";
import { Award, Wallet, RefreshCw, Flame, Ticket, Info, User as UserIcon, Clock, Loader2, Gift, Rocket, X, Bug, DollarSign, Coins, Send, Users, Check, ExternalLink, Plus, CalendarCheck, Bell, Star, Play, Sparkles, Zap, Settings, Film, Tv, Target, LayoutDashboard, ClipboardList, UserPlus, Share2, Copy, HeartHandshake, ArrowUpCircle, HandCoins, LogOut } from "lucide-react";
import { DiamondIcon } from "@/components/DiamondIcon";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { showNotification } from "@/components/AppNotification";
import { apiRequest } from "@/lib/queryClient";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { AnimatePresence, motion } from "framer-motion";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import WithdrawalPopup from "@/components/WithdrawalPopup";

// Unified Task Interface
interface UnifiedTask {
  id: string;
  type: 'advertiser';
  taskType: string;
  title: string;
  link: string | null;
  rewardHrum: number;
  rewardBUG?: number;
  rewardType: string;
  isAdminTask: boolean;
  isAdvertiserTask?: boolean;
  priority: number;
}

declare global {
  interface Window {
    show_10401872: (type?: string | { type: string; inAppSettings: any }) => Promise<void>;
    Adsgram: {
      init: (config: { blockId: string }) => {
        show: () => Promise<void>;
      };
    };
  }
}

interface User {
  id?: string;
  telegramId?: string;
  balance?: string;
  tonBalance?: string;
  bugBalance?: string;
  lastStreakDate?: string;
  username?: string;
  firstName?: string;
  telegramUsername?: string;
  referralCode?: string;
  [key: string]: any;
}

export default function Home() {
  const { user, isLoading } = useAuth();
  const { isAdmin } = useAdmin();
  const [, setLocation] = useLocation();
  const queryClient = useQueryClient();

  const [isConverting, setIsConverting] = useState(false);
  const [isClaimingStreak, setIsClaimingStreak] = useState(false);
  const [promoCode, setPromoCode] = useState("");
  const [isApplyingPromo, setIsApplyingPromo] = useState(false);
  const [hasClaimed, setHasClaimed] = useState(false);
  const [timeUntilNextClaim, setTimeUntilNextClaim] = useState<string>("");
  
  const [promoPopupOpen, setPromoPopupOpen] = useState(false);
  const [withdrawPopupOpen, setWithdrawPopupOpen] = useState(false);
  const [convertPopupOpen, setConvertPopupOpen] = useState(false);
  const [boosterPopupOpen, setBoosterPopupOpen] = useState(false);
  const [settingsOpen, setSettingsOpen] = useState(false);
  const [selectedConvertType, setSelectedConvertType] = useState<'' | 'BUG'>('');
  const [convertAmount, setConvertAmount] = useState<string>("");
  const [completedTasks, setCompletedTasks] = useState<Set<string>>(new Set());
  
  const [shareWithFriendsStep, setShareWithFriendsStep] = useState<'idle' | 'sharing' | 'countdown' | 'ready' | 'claiming'>('idle');
  const [dailyCheckinStep, setDailyCheckinStep] = useState<'idle' | 'ads' | 'countdown' | 'ready' | 'claiming'>('idle');
  const [checkForUpdatesStep, setCheckForUpdatesStep] = useState<'idle' | 'opened' | 'countdown' | 'ready' | 'claiming'>('idle');
  const [checkForUpdatesCountdown, setCheckForUpdatesCountdown] = useState(3);

  const { runAdFlow } = useAdFlow();

  const { data: leaderboardData } = useQuery<{
    userEarnerRank?: { rank: number; totalEarnings: string } | null;
  }>({
    queryKey: ['/api/leaderboard/monthly'],
    retry: false,
  });

  const { data: appSettings } = useQuery<any>({
    queryKey: ['/api/app-settings'],
    retry: false,
  });

  const { data: unifiedTasksData, isLoading: isLoadingTasks } = useQuery<{
    success: boolean;
    tasks: UnifiedTask[];
    completedTaskIds: string[];
    referralCode?: string;
  }>({
    queryKey: ['/api/tasks/home/unified'],
    queryFn: async () => {
      const res = await fetch('/api/tasks/home/unified', { credentials: 'include' });
      if (!res.ok) return { success: true, tasks: [], completedTaskIds: [] };
      return res.json();
    },
    retry: false,
  });

  const { data: missionStatus } = useQuery<any>({
    queryKey: ['/api/missions/status'],
    retry: false,
  });

  const { data: miningState, isLoading: isLoadingMining } = useQuery<any>({
    queryKey: ['/api/mining/state'],
    retry: false,
    staleTime: 10000,
  });

  const miningStateData = miningState || {};
  const [miningAmount, setMiningAmount] = useState(0);
  const miningRatePerHour = parseFloat(miningStateData.miningRate || "0.0015");
  const lastMiningClaim = miningStateData.lastClaim ? new Date(miningStateData.lastClaim).getTime() : Date.now();
  const miningRate = miningRatePerHour / 3600;

  useEffect(() => {
    if (miningStateData.currentMining) {
      setMiningAmount(parseFloat(miningStateData.currentMining));
    }
  }, [miningStateData.currentMining]);

  useEffect(() => {
    const interval = setInterval(() => {
      setMiningAmount(prev => prev + miningRate);
    }, 1000);
    return () => clearInterval(interval);
  }, [miningRate]);

  const claimMiningMutation = useMutation({
    mutationFn: async () => {
      const response = await apiRequest("POST", "/api/mining/claim");
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Failed to claim mining');
      }
      return response.json();
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["/api/auth/user"] });
      queryClient.invalidateQueries({ queryKey: ["/api/mining/state"] });
      showNotification(`+${parseFloat(data.amount).toFixed(2)} Hrum claimed from mining!`, "success");
    },
    onError: (error: any) => {
      showNotification(error.message, "error");
    },
  });

  const minMiningClaim = 1;
  const canClaimMining = miningState && parseFloat(miningState.minedAmount) >= minMiningClaim;

  // Render mining section (need to find where it is in the file)

  const { data: userData } = useQuery<{ referralCode?: string }>({
    queryKey: ['/api/auth/user'],
    retry: false,
    staleTime: 30000,
  });

  useEffect(() => {
    if (unifiedTasksData?.completedTaskIds) {
      setCompletedTasks(new Set(unifiedTasksData.completedTaskIds));
    } else {
      setCompletedTasks(new Set());
    }
  }, [unifiedTasksData]);

  const currentTask = unifiedTasksData?.tasks?.[0] || null;

  useEffect(() => {
    const updateTimer = () => {
      const now = new Date();
      const typedUser = user as User;
      
      if (typedUser?.id) {
        const claimedTimestamp = localStorage.getItem(`streak_claimed_${typedUser.id}`);
        if (claimedTimestamp) {
          const claimedDate = new Date(claimedTimestamp);
          const nextClaimTime = new Date(claimedDate.getTime() + 5 * 60 * 1000);
          
          if (now.getTime() < nextClaimTime.getTime()) {
            setHasClaimed(true);
            const diff = nextClaimTime.getTime() - now.getTime();
            const minutes = Math.floor(diff / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);
            setTimeUntilNextClaim(`${minutes}:${seconds.toString().padStart(2, '0')}`);
            return;
          } else {
            setHasClaimed(false);
            localStorage.removeItem(`streak_claimed_${typedUser.id}`);
          }
        }
      }
      
      if ((user as User)?.lastStreakDate) {
        const lastClaim = new Date((user as User).lastStreakDate!);
        const minutesSinceLastClaim = (now.getTime() - lastClaim.getTime()) / (1000 * 60);
        
        if (minutesSinceLastClaim < 5) {
          setHasClaimed(true);
          const nextClaimTime = new Date(lastClaim.getTime() + 5 * 60 * 1000);
          const diff = nextClaimTime.getTime() - now.getTime();
          const minutes = Math.floor(diff / (1000 * 60));
          const seconds = Math.floor((diff % (1000 * 60)) / 1000);
          setTimeUntilNextClaim(`${minutes}:${seconds.toString().padStart(2, '0')}`);
          return;
        }
      }
      
      setHasClaimed(false);
      setTimeUntilNextClaim("Available now");
    };

    updateTimer();
    const interval = setInterval(updateTimer, 1000);
    return () => clearInterval(interval);
  }, [(user as User)?.lastStreakDate, (user as User)?.id]);

  const convertMutation = useMutation({
    mutationFn: async ({ amount, convertTo }: { amount: number; convertTo: string }) => {
      const res = await fetch("/api/convert-to-ton", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify({ hrumAmount: amount, convertTo }),
      });
      const data = await res.json();
      if (!res.ok) {
        throw new Error(data.message || "Failed to convert");
      }
      return data;
    },
    onSuccess: async () => {
      showNotification("Convert successful.", "success");
      queryClient.invalidateQueries({ queryKey: ["/api/auth/user"] });
      queryClient.invalidateQueries({ queryKey: ["/api/user/stats"] });
      setConvertPopupOpen(false);
    },
    onError: (error: Error) => {
      showNotification(error.message, "error");
    },
  });

  const claimStreakMutation = useMutation({
    mutationFn: async () => {
      const response = await apiRequest("POST", "/api/streak/claim");
      if (!response.ok) {
        const error = await response.json();
        const errorObj = new Error(error.message || 'Failed to claim streak');
        (errorObj as any).isAlreadyClaimed = error.message === "Please wait 5 minutes before claiming again!";
        throw errorObj;
      }
      return response.json();
    },
    onSuccess: (data) => {
      setHasClaimed(true);
      const typedUser = user as User;
      if (typedUser?.id) {
        localStorage.setItem(`streak_claimed_${typedUser.id}`, new Date().toISOString());
      }
      queryClient.invalidateQueries({ queryKey: ["/api/auth/user"] });
      queryClient.invalidateQueries({ queryKey: ["/api/user/stats"] });
      const rewardAmount = parseFloat(data.rewardEarned || '0');
      if (rewardAmount > 0) {
        const earnedHrum = Math.round(rewardAmount);
        showNotification(`You've claimed +${earnedHrum} Hrum!`, "success");
      } else {
        showNotification("You've claimed your streak bonus!", "success");
      }
    },
    onError: (error: any) => {
      const notificationType = error.isAlreadyClaimed ? "info" : "error";
      showNotification(error.message || "Failed to claim streak", notificationType);
      if (error.isAlreadyClaimed) {
        setHasClaimed(true);
        const typedUser = user as User;
        if (typedUser?.id) {
          localStorage.setItem(`streak_claimed_${typedUser.id}`, new Date().toISOString());
        }
      }
    },
    onSettled: () => {
      setIsClaimingStreak(false);
    },
  });

  const redeemPromoMutation = useMutation({
    mutationFn: async (code: string) => {
      const response = await apiRequest("POST", "/api/promo-codes/redeem", { code });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.message || "Invalid promo code");
      }
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["/api/auth/user"] });
      queryClient.invalidateQueries({ queryKey: ["/api/earnings"] });
      queryClient.invalidateQueries({ queryKey: ["/api/user/stats"] });
      setPromoCode("");
      setPromoPopupOpen(false);
      setIsApplyingPromo(false);
      showNotification(data.message || "Promo applied successfully!", "success");
    },
    onError: (error: any) => {
      const message = error.message || "Invalid promo code";
      showNotification(message, "error");
      setIsApplyingPromo(false);
    },
  });

  const [clickedTasks, setClickedTasks] = useState<Set<string>>(new Set());

  const advertiserTaskMutation = useMutation({
    mutationFn: async (taskId: string) => {
      const res = await fetch(`/api/advertiser-tasks/${taskId}/click`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({}),
      });
      const data = await res.json();
      if (!data.success) throw new Error(data.message || 'Failed to start task');
      return data;
    },
    onSuccess: async (data, taskId) => {
      setClickedTasks(prev => new Set(prev).add(taskId));
      showNotification("Task started! Click the claim button to earn your reward.", "info");
    },
    onError: (error: any) => {
      showNotification(error.message || 'Failed to start task', 'error');
    },
  });

  const claimAdvertiserTaskMutation = useMutation({
    mutationFn: async ({ taskId, taskType, link }: { taskId: string, taskType: string, link: string | null }) => {
      // Step 1: Real-time verification for channel tasks
      if (taskType === 'channel' && link) {
        const username = link.replace('https://t.me/', '').split('?')[0];
        const currentTelegramData = (window as any).Telegram?.WebApp?.initData || '';
        
        const resVerify = await fetch('/api/tasks/verify/channel', {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'x-telegram-data': currentTelegramData || ''
          },
          body: JSON.stringify({ channelId: `@${username}` }),
          credentials: 'include',
        });
        
        const verifyData = await resVerify.json();
        if (!resVerify.ok || !verifyData.isJoined) {
          throw new Error('Please join the channel to complete this task.');
        }
      }

      // Step 2: Claim reward
      const res = await fetch(`/api/advertiser-tasks/${taskId}/claim`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
      });
      const data = await res.json();
      if (!data.success) throw new Error(data.message || 'Failed to claim reward');
      return data;
    },
    onSuccess: async (data) => {
      queryClient.invalidateQueries({ queryKey: ['/api/auth/user'] });
      await queryClient.refetchQueries({ queryKey: ['/api/tasks/home/unified'] });
      const hrumReward = Number(data.reward ?? 0);
      showNotification(`+${hrumReward.toLocaleString()} Hrum earned!`, 'success');
    },
    onError: (error: any) => {
      showNotification(error.message || 'Failed to claim reward', 'error');
    },
  });

  const handleUnifiedTask = (task: UnifiedTask) => {
    if (!task) return;
    
    if (clickedTasks.has(task.id)) {
      claimAdvertiserTaskMutation.mutate({ taskId: task.id, taskType: task.taskType, link: task.link });
      return;
    }

    if (task.link) {
      window.open(task.link, '_blank');
      advertiserTaskMutation.mutate(task.id);
    } else {
      advertiserTaskMutation.mutate(task.id);
    }
  };

  const getTaskIcon = (task: UnifiedTask) => {
    return task.taskType === 'channel' ? <Send className="w-4 h-4" /> : 
           task.taskType === 'bot' ? <ExternalLink className="w-4 h-4" /> :
           <ExternalLink className="w-4 h-4" />;
  };

  const isTaskPending = advertiserTaskMutation.isPending;

  const showAdsgramAd = (): Promise<boolean> => {
    return new Promise(async (resolve) => {
      if ((window as any).Adsgram) {
        try {
          await (window as any).Adsgram.init({ blockId: "int-20373" }).show();
          resolve(true);
        } catch (error) {
          console.error('Adsgram ad error:', error);
          resolve(false);
        }
      } else {
        resolve(false);
      }
    });
  };

  const showMonetagAd = (): Promise<{ success: boolean; unavailable: boolean }> => {
    return new Promise((resolve) => {
      if (typeof window.show_10401872 === 'function') {
        window.show_10401872()
          .then(() => {
            resolve({ success: true, unavailable: false });
          })
          .catch((error) => {
            console.error('Monetag ad error:', error);
            resolve({ success: false, unavailable: false });
          });
      } else {
        resolve({ success: false, unavailable: true });
      }
    });
  };

  const showMonetagRewardedAd = (): Promise<{ success: boolean; unavailable: boolean }> => {
    return new Promise((resolve) => {
      console.log('üé¨ Attempting to show Monetag rewarded ad...');
      if (typeof window.show_10401872 === 'function') {
        console.log('‚úÖ Monetag SDK found, calling rewarded ad...');
        window.show_10401872()
          .then(() => {
            console.log('‚úÖ Monetag rewarded ad completed successfully');
            resolve({ success: true, unavailable: false });
          })
          .catch((error) => {
            console.error('‚ùå Monetag rewarded ad error:', error);
            resolve({ success: false, unavailable: false });
          });
      } else {
        console.log('‚ö†Ô∏è Monetag SDK not available, skipping ad');
        resolve({ success: false, unavailable: true });
      }
    });
  };

  const [loadingProvider, setLoadingProvider] = useState<string | null>(null);
  const [adStartTime, setAdStartTime] = useState<number>(0);
  const { data: stats } = useQuery<any>({
    queryKey: ['/api/referrals/stats'],
    retry: false,
    staleTime: 60000,
  });

  const botUsername = import.meta.env.VITE_BOT_USERNAME || 'MoneyAdzbot';
  const referralLink = user?.referralCode 
    ? `https://t.me/${botUsername}?start=${user.referralCode}`
    : '';

  const copyReferralLink = () => {
    if (referralLink) {
      navigator.clipboard.writeText(referralLink);
      showNotification('Link copied!', 'success');
    }
  };

  const [isSharing, setIsSharing] = useState(false);

  const shareReferralLink = async () => {
    if (!referralLink || isSharing) return;
    setIsSharing(true);
    
    try {
      const tgWebApp = (window as any).Telegram?.WebApp;
      
      // Native Telegram share: Use shareMessage() with prepared message from backend
      if (tgWebApp?.shareMessage) {
        try {
          // First, prepare the message on the backend
          const response = await fetch('/api/share/prepare-message', {
            method: 'POST',
            credentials: 'include',
            headers: { 'Content-Type': 'application/json' }
          });
          const data = await response.json();
          
          if (data.success && data.messageId) {
            // Use the native Telegram share dialog with prepared message
            tgWebApp.shareMessage(data.messageId, (success: boolean) => {
              if (success) {
                showNotification('Message shared successfully!', 'success');
              }
              setIsSharing(false);
            });
            return;
          } else if (data.fallbackUrl) {
            // Backend returned fallback URL
            tgWebApp.openTelegramLink(data.fallbackUrl);
            setIsSharing(false);
            return;
          }
        } catch (error) {
          console.error('Prepare message error:', error);
        }
      }
      
      // Fallback: Use Telegram's native share URL dialog
      const shareTitle = `üíµ Get paid for completing tasks and watching ads.`;
      const shareUrl = `https://t.me/share/url?url=${encodeURIComponent(referralLink)}&text=${encodeURIComponent(shareTitle)}`;
      
      if (tgWebApp?.openTelegramLink) {
        tgWebApp.openTelegramLink(shareUrl);
      } else {
        window.open(shareUrl, '_blank');
      }
    } catch (error) {
      console.error('Share error:', error);
    }
    
    setIsSharing(false);
  };

  const watchAdMutation = useMutation({
    mutationFn: async (adType: string) => {
      const response = await apiRequest("POST", "/api/ads/watch", { adType });
      if (!response.ok) {
        const error = await response.json();
        throw { status: response.status, ...error };
      }
      return response.json();
    },
    onSuccess: async (data) => {
      queryClient.setQueryData(["/api/auth/user"], (old: any) => ({
        ...old,
        balance: data.newBalance,
        adsWatchedToday: data.adsWatchedToday
      }));
      
      queryClient.invalidateQueries({ queryKey: ["/api/user/stats"] });
      queryClient.invalidateQueries({ queryKey: ["/api/earnings"] });
      
      showNotification(`You received ${Math.round(data.rewardHrum || 1000)} Hrum on your balance`, "success");
      setLoadingProvider(null);
    },
    onError: (error: any) => {
      if (error.status === 429) {
        const limit = error.limit || appSettings?.dailyAdLimit || 50;
        showNotification(`Daily ad limit reached (${limit} ads/day)`, "error");
      } else if (error.status === 401 || error.status === 403) {
        showNotification("Authentication error. Please refresh the page.", "error");
      } else if (error.message) {
        showNotification(`Error: ${error.message}`, "error");
      } else {
        showNotification("Network error. Check your connection and try again.", "error");
      }
      setLoadingProvider(null);
    },
  });

  const handleWatchAd = async (providerId: string) => {
    if (loadingProvider) return;
    
    setLoadingProvider(providerId);
    const startTime = Date.now();
    setAdStartTime(startTime);
    
    const handleAdCompletion = () => {
      const watchDuration = Date.now() - startTime;
      if (watchDuration < 3000) {
        showNotification("Claiming too fast!", "error");
        setLoadingProvider(null);
        return;
      }
      watchAdMutation.mutate(providerId);
    };

    const handleAdError = (error?: any) => {
      showNotification("Ad failed to load. Please try again.", "error");
      setLoadingProvider(null);
    };
    
    try {
      switch (providerId) {
        case 'monetag':
          if (typeof (window as any).show_10013974 === 'function') {
            (window as any).show_10013974()
              .then(() => {
                handleAdCompletion();
              })
              .catch((error: any) => {
                console.error('‚ùå Monetag ad error:', error);
                handleAdError(error);
              });
          } else {
            showNotification("Monetag not available. Try again later.", "error");
            setLoadingProvider(null);
          }
          break;
          
        case 'adexora':
          if (typeof (window as any).showAdexora === 'function') {
            (window as any).showAdexora()
              .then(() => {
                handleAdCompletion();
              })
              .catch((error: any) => {
                console.error('‚ùå Adexora ad error:', error);
                handleAdError(error);
              });
          } else {
            showNotification("Adexora not available. Please open in Telegram app.", "error");
            setLoadingProvider(null);
          }
          break;
          
        case 'adextra':
          const adExtraContainer = document.getElementById('353c332d4f2440f448057df79cb605e5d3d64ef0');
          if (adExtraContainer) {
            adExtraContainer.style.display = 'flex';
            adExtraContainer.style.alignItems = 'center';
            adExtraContainer.style.justifyContent = 'center';
            
            let closeBtn = document.getElementById('adextra-close-btn') as HTMLButtonElement | null;
            let skipBtn = document.getElementById('adextra-skip-btn') as HTMLButtonElement | null;
            
            if (!closeBtn) {
              closeBtn = document.createElement('button');
              closeBtn.id = 'adextra-close-btn';
              closeBtn.style.cssText = 'position:absolute;top:20px;right:20px;background:#4cd3ff;color:#000;border:none;padding:12px 24px;border-radius:8px;font-weight:bold;cursor:pointer;z-index:10000;display:none;';
              closeBtn.textContent = 'Claim Reward';
              adExtraContainer.appendChild(closeBtn);
            }
            
            if (!skipBtn) {
              skipBtn = document.createElement('button');
              skipBtn.id = 'adextra-skip-btn';
              skipBtn.style.cssText = 'position:absolute;top:20px;left:20px;background:#333;color:#fff;border:none;padding:8px 16px;border-radius:8px;cursor:pointer;z-index:10000;';
              skipBtn.textContent = 'Close';
              adExtraContainer.appendChild(skipBtn);
            }
            
            closeBtn.style.display = 'none';
            skipBtn.style.display = 'block';
            let adLoadedAndViewed = false;
            let contentCheckInterval: NodeJS.Timeout | null = null;
            
            const checkForAdContent = () => {
              const hasContent = adExtraContainer.querySelector('iframe, img, video, div[class]');
              return hasContent !== null && adExtraContainer.childElementCount > 2;
            };
            
            contentCheckInterval = setInterval(() => {
              if (checkForAdContent()) {
                if (contentCheckInterval) clearInterval(contentCheckInterval);
                setTimeout(() => {
                  if (closeBtn) {
                    closeBtn.style.display = 'block';
                    adLoadedAndViewed = true;
                  }
                }, 5000);
              }
            }, 500);
            
            setTimeout(() => {
              if (contentCheckInterval) clearInterval(contentCheckInterval);
              if (!adLoadedAndViewed && closeBtn) {
                closeBtn.style.display = 'none';
              }
            }, 15000);
            
            const handleClaim = () => {
              if (contentCheckInterval) clearInterval(contentCheckInterval);
              adExtraContainer.style.display = 'none';
              if (closeBtn) closeBtn.style.display = 'none';
              if (skipBtn) skipBtn.style.display = 'none';
              closeBtn?.removeEventListener('click', handleClaim);
              skipBtn?.removeEventListener('click', handleSkip);
              
              if (adLoadedAndViewed) {
                handleAdCompletion();
              } else {
                showNotification("Ad did not load properly", "error");
                setLoadingProvider(null);
              }
            };
            
            const handleSkip = () => {
              if (contentCheckInterval) clearInterval(contentCheckInterval);
              adExtraContainer.style.display = 'none';
              if (closeBtn) closeBtn.style.display = 'none';
              if (skipBtn) skipBtn.style.display = 'none';
              closeBtn?.removeEventListener('click', handleClaim);
              skipBtn?.removeEventListener('click', handleSkip);
              showNotification("Ad skipped - no reward earned", "info");
              setLoadingProvider(null);
            };
            
            closeBtn.addEventListener('click', handleClaim);
            skipBtn.addEventListener('click', handleSkip);
          } else {
            showNotification("AdExtra not available. Try again later.", "error");
            setLoadingProvider(null);
          }
          break;
          
        case 'adsgram':
          if ((window as any).Adsgram) {
            try {
              await (window as any).Adsgram.init({ blockId: "int-18225" }).show();
              handleAdCompletion();
            } catch (error) {
              handleAdError(error);
            }
          } else {
            showNotification("Adsgram not available. Try again later.", "error");
            setLoadingProvider(null);
          }
          break;
          
        default:
          showNotification("Unknown ad provider", "error");
          setLoadingProvider(null);
      }
    } catch (error) {
      showNotification("Ad display failed. Please try again.", "error");
      setLoadingProvider(null);
    }
  };

  const adsWatchedToday = (user as any)?.adsWatchedToday || 0;
  const dailyLimit = appSettings?.dailyAdLimit || 50;

  const handleConvertClick = () => {
    setConvertPopupOpen(true);
  };

  const rawBalance = parseFloat((user as User)?.balance || "0");
  const padBalance = rawBalance < 1 ? Math.round(rawBalance * 10000000) : Math.round(rawBalance);
  const tonBalance = parseFloat((user as User)?.tonBalance || "0");
  const balance = parseFloat((user as User)?.balance || "0");
  const balanceBUG = parseFloat((user as User)?.bugBalance || "0");
  const withdrawBalance = parseFloat((user as User)?.tonBalance || "0");
  
  const displayName = (window as any).Telegram?.WebApp?.initDataUnsafe?.user?.first_name || (user as User)?.firstName || (user as User)?.username || "User";
  const photoUrl = typeof window !== 'undefined' && (window as any).Telegram?.WebApp?.initDataUnsafe?.user?.photo_url;

  const handleConvertConfirm = async () => {
    const amount = parseFloat(convertAmount);
    if (isNaN(amount) || amount <= 0) {
      showNotification("Please enter a valid amount", "error");
      return;
    }

    const minimumConvertHrum = selectedConvertType === '' 
      ? (appSettings?.minimumConvertHrum || 10000)
      : (selectedConvertType === 'BUG' ? (appSettings?.minimumConvertPadToBug || 1000) : (appSettings?.minimumConvertPadToTon || 10000));
    
    if (amount < minimumConvertHrum) {
      showNotification(`Minimum ${minimumConvertHrum.toLocaleString()} Hrum required.`, "error");
      return;
    }

    if (padBalance < amount) {
      showNotification("Insufficient Hrum balance", "error");
      return;
    }

    if (isConverting || convertMutation.isPending) return;
    
    setIsConverting(true);
    console.log('üí± Convert started, showing AdsGram ad first...');
    
    try {
      const monetagResult = await showMonetagRewardedAd();
      
      if (monetagResult.unavailable) {
        console.log('‚ö†Ô∏è Monetag unavailable, proceeding with convert');
        convertMutation.mutate({ amount, convertTo: selectedConvertType || 'TON' });
        return;
      }
      
      if (!monetagResult.success) {
        showNotification("Please watch the ad to convert.", "error");
        setIsConverting(false);
        return;
      }
      
      console.log('‚úÖ Ad watched, converting');
      convertMutation.mutate({ amount, convertTo: selectedConvertType || 'TON' });
      
    } catch (error) {
      console.error('Convert error:', error);
      showNotification("Something went wrong. Please try again.", "error");
    } finally {
      setIsConverting(false);
    }
  };

  const canClaimStreak = !hasClaimed;

  const handleClaimStreak = async () => {
    if (isClaimingStreak || hasClaimed) return;
    
    setIsClaimingStreak(true);
    
    try {
      // Then show Monetag rewarded ad
      const monetagResult = await showMonetagRewardedAd();
      
      if (monetagResult.unavailable) {
        // If Monetag unavailable, proceed
        claimStreakMutation.mutate();
        return;
      }
      
      if (!monetagResult.success) {
        showNotification("Please watch the ad completely to claim your bonus.", "error");
        setIsClaimingStreak(false);
        return;
      }
      
      claimStreakMutation.mutate();
    } catch (error) {
      console.error('Streak claim failed:', error);
      showNotification("Failed to claim streak. Please try again.", "error");
      setIsClaimingStreak(false);
    }
  };

  useEffect(() => {
    if (checkForUpdatesStep === 'countdown' && checkForUpdatesCountdown > 0) {
      const timer = setTimeout(() => setCheckForUpdatesCountdown(prev => prev - 1), 1000);
      return () => clearTimeout(timer);
    } else if (checkForUpdatesStep === 'countdown' && checkForUpdatesCountdown === 0) {
      setCheckForUpdatesStep('ready');
    }
  }, [checkForUpdatesStep, checkForUpdatesCountdown]);

  const handleApplyPromo = async () => {
    if (!promoCode.trim()) {
      showNotification("Please enter a promo code", "error");
      return;
    }

    if (isApplyingPromo || redeemPromoMutation.isPending) return;
    
    setIsApplyingPromo(true);
    console.log('üé´ Promo code claim started, showing AdsGram ad first...');
    
    try {
      // Then show Monetag rewarded ad
      console.log('üé¨ Proceeding with Monetag rewarded...');
      const monetagResult = await showMonetagRewardedAd();
      
      if (monetagResult.unavailable) {
        // If Monetag unavailable, proceed
        console.log('‚ö†Ô∏è Monetag unavailable, proceeding with promo claim');
        redeemPromoMutation.mutate(promoCode.trim().toUpperCase());
        return;
      }
      
      if (!monetagResult.success) {
        showNotification("Please watch the ad to claim your promo code.", "error");
        setIsApplyingPromo(false);
        return;
      }
      
      console.log('‚úÖ Ad watched, claiming promo code');
      redeemPromoMutation.mutate(promoCode.trim().toUpperCase());
    } catch (error) {
      console.error('Promo claim error:', error);
      showNotification("Something went wrong. Please try again.", "error");
      setIsApplyingPromo(false);
    }
  };

  const handleBoosterClick = () => {
    setBoosterPopupOpen(true);
  };

  const handleWatchExtraAd = async () => {
    if (isTaskPending) return;
    
    showNotification("Ad sequence starting...", "info");
    
    try {
      // 1. Show Monetag
      const monetagResult = await showMonetagRewardedAd();
      if (!monetagResult.success && !monetagResult.unavailable) {
        throw new Error("Please watch the Monetag ad completely.");
      }
      
      // Small delay between ads
      await new Promise(resolve => setTimeout(resolve, 500));

      // 2. Show GigaPub
      console.log('üé¨ Attempting GigaPub ad...');
      if (typeof (window as any).showGiga === 'function') {
        console.log('‚úÖ Calling window.showGiga()');
        (window as any).showGiga();
        // Give some time for the ad to at least start showing
        await new Promise(resolve => setTimeout(resolve, 3000));
      } else {
        console.error("‚ùå GigaPub not available. Please refresh or check your ad blocker.");
        throw new Error("GigaPub ad service not ready. Please refresh.");
      }
      
      // 3. Reward
      const response = await apiRequest("POST", "/api/ads/extra-watch");
      if (!response.ok) {
        const error = await response.json();
        throw error;
      }
      const data = await response.json();
      
      queryClient.setQueryData(["/api/auth/user"], (old: any) => ({
        ...old,
        balance: data.newBalance,
        extraAdsWatchedToday: data.extraAdsWatchedToday
      }));
      
      showNotification(`You received ${data.rewardHrum} Hrum for Extra Earn!`, "success");
    } catch (error: any) {
      console.error('Extra earn error:', error);
      showNotification(error.message || "Extra Earn ad failed", "error");
    }
  };

  const handleShareWithFriends = useCallback(() => {
    if (!referralLink) return;
    const tgWebApp = (window as any).Telegram?.WebApp;
    const shareUrl = `https://t.me/share/url?url=${encodeURIComponent(referralLink)}&text=${encodeURIComponent("Join me on CashWatch and earn rewards together!")}`;
    if (tgWebApp?.openTelegramLink) {
      tgWebApp.openTelegramLink(shareUrl);
    } else {
      window.open(shareUrl, '_blank');
    }
    setShareWithFriendsStep('ready');
  }, [referralLink]);

  const shareWithFriendsMutation = useMutation({
    mutationFn: async () => {
      const res = await apiRequest("POST", "/api/missions/claim", { missionId: 'shareStory' });
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/missions/status'] });
      queryClient.invalidateQueries({ queryKey: ['/api/auth/user'] });
      showNotification("Rewards claimed!", "success");
      setShareWithFriendsStep('idle');
    }
  });

  const handleClaimShareWithFriends = useCallback(() => {
    shareWithFriendsMutation.mutate();
  }, [shareWithFriendsMutation]);

  const dailyCheckinMutation = useMutation({
    mutationFn: async () => {
      const res = await apiRequest("POST", "/api/missions/claim", { missionId: 'dailyCheckin' });
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/missions/status'] });
      queryClient.invalidateQueries({ queryKey: ['/api/auth/user'] });
      showNotification("Daily check-in successful!", "success");
      setDailyCheckinStep('idle');
    }
  });

  const handleDailyCheckin = useCallback(async () => {
    if (missionStatus?.dailyCheckin?.claimed || dailyCheckinStep !== 'idle') return;
    setDailyCheckinStep('ads');
    const adResult = await runAdFlow();
    if (!adResult.monetagWatched) {
      showNotification("Please watch the ads completely to claim!", "error");
      setDailyCheckinStep('idle');
      return;
    }
    setDailyCheckinStep('ready');
  }, [missionStatus?.dailyCheckin?.claimed, dailyCheckinStep, runAdFlow]);

  const handleClaimDailyCheckin = useCallback(() => {
    if (dailyCheckinMutation.isPending) return;
    setDailyCheckinStep('claiming');
    dailyCheckinMutation.mutate();
  }, [dailyCheckinMutation]);

  const checkForUpdatesMutation = useMutation({
    mutationFn: async () => {
      const res = await apiRequest("POST", "/api/missions/claim", { missionId: 'checkForUpdates' });
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/missions/status'] });
      queryClient.invalidateQueries({ queryKey: ['/api/auth/user'] });
      showNotification("Rewards claimed!", "success");
      setCheckForUpdatesStep('idle');
    }
  });

  const handleCheckForUpdates = useCallback(() => {
    if (missionStatus?.checkForUpdates?.claimed || checkForUpdatesStep !== 'idle') return;
    const tgWebApp = (window as any).Telegram?.WebApp;
    const channelUrl = 'https://t.me/MoneyAdz';
    if (tgWebApp?.openTelegramLink) {
      tgWebApp.openTelegramLink(channelUrl);
    } else if (tgWebApp?.openLink) {
      tgWebApp.openLink(channelUrl);
    } else {
      window.open(channelUrl, '_blank');
    }
    setCheckForUpdatesStep('opened');
    setCheckForUpdatesCountdown(3);
    const countdownInterval = setInterval(() => {
      setCheckForUpdatesCountdown(prev => {
        if (prev <= 1) {
          clearInterval(countdownInterval);
          setCheckForUpdatesStep('ready');
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
  }, [missionStatus?.checkForUpdates?.claimed, checkForUpdatesStep]);

  const handleClaimCheckForUpdates = useCallback(() => {
    if (checkForUpdatesMutation.isPending) return;
    setCheckForUpdatesStep('claiming');
    checkForUpdatesMutation.mutate();
  }, [checkForUpdatesMutation]);

  if (isLoading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="text-center">
          <div className="flex gap-1 justify-center mb-4">
            <div className="w-2 h-2 rounded-full bg-[#4cd3ff] animate-bounce" style={{ animationDelay: '0ms' }}></div>
            <div className="w-2 h-2 rounded-full bg-[#4cd3ff] animate-bounce" style={{ animationDelay: '150ms' }}></div>
            <div className="w-2 h-2 rounded-full bg-[#4cd3ff] animate-bounce" style={{ animationDelay: '300ms' }}></div>
          </div>
          <div className="text-foreground font-medium">Loading...</div>
        </div>
      </div>
    );
  }

  const userRank = leaderboardData?.userEarnerRank?.rank;

  // Values are now derived from miningState above

  const handleClaimClick = () => {
    if (miningAmount < 1) {
      showNotification("Minimum claim is 1 HRUM", "error");
      return;
    }
    claimMiningMutation.mutate();
  };

  return (
    <Layout>
      <main className="max-w-md mx-auto px-4 pt-4 pb-4 overflow-y-auto">
        {/* Unified Profile & Balance Section */}
        <div className="mb-4 relative">
          <div className="flex justify-between items-center mb-4">
            <div className="flex items-center gap-3">
              <div 
                className={`w-11 h-11 rounded-full overflow-hidden flex items-center justify-center border border-white/5 bg-[#1a1a1a] cursor-pointer hover:opacity-80 transition-opacity`}
                onClick={() => setLocation("/admin")}
              >
                {photoUrl ? (
                  <img 
                    src={photoUrl} 
                    alt="Profile" 
                    className="w-full h-full object-cover"
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center">
                    <UserIcon className="w-6 h-6 text-gray-400" />
                  </div>
                )}
              </div>
              <div className="flex flex-col">
                <span 
                  className={`text-white font-black text-base leading-none tracking-tight cursor-pointer hover:opacity-80`}
                  onClick={() => setLocation("/admin")}
                >
                  {(user as User)?.firstName || (window as any).Telegram?.WebApp?.initDataUnsafe?.user?.first_name || "User"}
                </span>
                <span className="text-[#B9FF66] text-[10px] font-black uppercase tracking-widest mt-1 opacity-90">
                  ID: {(user as User)?.id?.substring(0, 8) || "N/A"}
                </span>
              </div>
            </div>
            
            <Button
              onClick={() => setWithdrawPopupOpen(true)}
              className="bg-[#1a1a1a] hover:bg-[#222] text-[#4cd3ff] border border-[#4cd3ff]/20 rounded-xl px-4 py-1.5 h-auto text-xs font-black uppercase tracking-wider transition-all active:scale-95"
            >
              WITHDRAW
            </Button>
          </div>

          <div className="bg-[#141414] rounded-2xl px-4 py-2 flex justify-between items-center mb-4 border border-white/5 h-12">
            <div className="flex flex-col items-center flex-1">
              <span className="text-[#8E8E93] text-[9px] font-semibold uppercase tracking-wider mb-0.5">Total HRUM Mined</span>
              <div className="flex items-center gap-1.5 leading-none">
                <div className="w-4 h-4 flex items-center justify-center flex-shrink-0">
                  <img src="/images/hrum-logo.jpg" alt="Hrum" className="w-full h-full object-cover rounded-sm" />
                </div>
                <span className="text-white text-base font-black tabular-nums">
                  {Math.floor(parseFloat(user?.balance || "0")).toLocaleString()}
                </span>
              </div>
            </div>
            <div className="w-[1px] h-6 bg-white/10 mx-1"></div>
            <div className="flex flex-col items-center flex-1">
              <div className="flex items-center gap-1 mb-0.5 leading-none">
                <span className="text-[#8E8E93] text-[9px] font-semibold uppercase tracking-wider">Total TON Earned</span>
              </div>
              <div className="flex items-center gap-1.5 leading-none">
                <div className="w-4 h-4 flex items-center justify-center flex-shrink-0">
                  <img src="/images/ton.png" alt="TON" className="w-full h-full object-cover rounded-full" />
                </div>
                <span className="text-white text-base font-black tabular-nums">
                  {user?.tonBalance ? parseFloat(user.tonBalance).toFixed(3) : "0.000"}
                </span>
              </div>
            </div>
          </div>
          <div className="bg-[#141414] rounded-2xl p-4 border border-white/5 mb-4">
            <div className="flex justify-between items-center mb-4">
              <span className="text-[#8E8E93] text-[10px] font-black uppercase tracking-widest">MINING STATUS</span>
              <div className="flex items-center gap-1.5">
                <div className="w-1.5 h-1.5 bg-[#B9FF66] rounded-full animate-pulse"></div>
                <span className="text-[#B9FF66] text-[10px] font-black uppercase tracking-widest">ACTIVE</span>
              </div>
            </div>
            
            <div className="text-center mb-4">
              <div className="text-[#8E8E93] text-[9px] font-semibold uppercase tracking-wider mb-1">MINED HRUM</div>
              <div className="text-3xl font-black text-white tabular-nums tracking-tight">
                {miningAmount.toFixed(6)}
              </div>
              <div className="flex items-center justify-center gap-1 mt-1 text-[#B9FF66] text-[11px] font-bold">
                <Zap className="w-3 h-3 fill-current" />
                {(miningRatePerHour || 0.0015).toFixed(4)} H/h
              </div>
            </div>

            <div className="grid grid-cols-2 gap-3 mb-4">
              <Button 
                onClick={() => setLocation("/shop")}
                className="bg-[#1a1a1a] hover:bg-[#222] text-white rounded-xl py-2.5 text-xs font-bold border border-white/5 h-auto uppercase tracking-wider flex items-center justify-center gap-2"
              >
                <ArrowUpCircle className="w-3.5 h-3.5" />
                UPGRADE
              </Button>
              <Button 
                onClick={handleClaimClick}
                disabled={claimMiningMutation.isPending}
                className={`${
                  miningAmount >= 1 
                    ? "bg-[#B9FF66] hover:bg-[#a8e655] text-black" 
                    : "bg-[#1a1a1a] hover:bg-[#222] text-white border border-white/5"
                } rounded-xl py-2.5 text-xs font-bold h-auto uppercase tracking-wider flex items-center justify-center gap-2 transition-all`}
              >
                {claimMiningMutation.isPending ? <Loader2 className="w-3 h-3 animate-spin" /> : (
                  <>
                    <HandCoins className="w-3.5 h-3.5" />
                    CLAIM
                  </>
                )}
              </Button>
            </div>

            {/* Action Buttons inside profile section */}
            <div className="grid grid-cols-2 gap-3 pt-4 border-t border-white/5">
              <Button
                onClick={handleConvertClick}
                className="bg-[#1a1a1a] hover:bg-[#222] text-[#B9FF66] rounded-2xl py-2.5 text-sm font-bold flex items-center justify-center gap-2 border border-[#B9FF66]/10 h-auto transition-transform active:scale-95 uppercase tracking-wider"
              >
                <RefreshCw className="w-4 h-4" />
                Convert
              </Button>
              <Button
                onClick={() => setPromoPopupOpen(true)}
                className="bg-[#1a1a1a] hover:bg-[#222] text-[#B9FF66] rounded-2xl py-2.5 text-sm font-bold flex items-center justify-center gap-2 border border-[#B9FF66]/10 h-auto transition-transform active:scale-95 uppercase tracking-wider"
              >
                <Ticket className="w-4 h-4" />
                Promo
              </Button>
            </div>

            {/* Tab section inside Profile section */}
            <div className="mt-4">
              <Tabs defaultValue="earn" className="w-full">
                <TabsList className="grid w-full grid-cols-2 bg-[#0d0d0d] border-b border-white/5 h-12 p-0 rounded-none mb-4">
                  <TabsTrigger 
                    value="earn" 
                    className="flex items-center justify-center gap-2 font-black text-[11px] uppercase tracking-wider rounded-none data-[state=active]:bg-transparent data-[state=active]:text-white transition-all relative h-full"
                  >
                    <LayoutDashboard className="w-4 h-4" />
                    Earn
                    <div className="absolute bottom-0 left-0 right-0 h-0.5 bg-blue-500 opacity-0 data-[state=active]:opacity-100 transition-opacity"></div>
                  </TabsTrigger>
                  <TabsTrigger 
                    value="referrals" 
                    className="flex items-center justify-center gap-2 font-black text-[11px] uppercase tracking-wider rounded-none data-[state=active]:bg-transparent data-[state=active]:text-white transition-all relative h-full"
                  >
                    <HeartHandshake className="w-4 h-4" />
                    Referrals
                    <div className="absolute bottom-0 left-0 right-0 h-0.5 bg-blue-500 opacity-0 data-[state=active]:opacity-100 transition-opacity"></div>
                  </TabsTrigger>
                </TabsList>

                <TabsContent value="earn" className="mt-0 outline-none">
                  <div className="space-y-4 pt-1">
                    <AdWatchingSection user={user as User} />
                  </div>
                </TabsContent>

                <TabsContent value="referrals" className="mt-0 outline-none">
                  <div className="flex flex-col items-center text-center pt-4">
                    <h2 className="text-xl font-bold text-white mb-1">Invite friends and earn</h2>
                    <p className="text-[13px] text-[#8E8E93] mb-5 max-w-[280px] leading-snug">
                      10% of their Hrum and When your friend buys a plan you get <span className="font-bold">{appSettings?.referralRewardHrum || 50} Hrum</span> instantly
                    </p>

                    <div className="w-full bg-[#111111] rounded-[24px] p-5 mb-5 flex justify-around">
                      <div>
                        <p className="text-[10px] text-[#8E8E93] mb-1 uppercase font-bold tracking-wider">User referred</p>
                        <p className="text-2xl font-black text-white">{stats?.totalInvites || 0}</p>
                      </div>
                      <div>
                        <p className="text-[10px] text-[#8E8E93] mb-1 uppercase font-bold tracking-wider">Successful</p>
                        <p className="text-2xl font-black text-white">{stats?.successfulInvites || 0}</p>
                      </div>
                    </div>

                    <div className="flex w-full gap-2">
                      <Button
                        onClick={copyReferralLink}
                        disabled={!referralLink}
                        className="flex-1 h-12 bg-[#111111] hover:bg-[#1a1a1a] text-white rounded-2xl font-bold text-sm gap-2"
                      >
                        <Copy className="w-4 h-4" />
                        Copy Link
                      </Button>
                      <Button
                        onClick={shareReferralLink}
                        disabled={!referralLink || isSharing}
                        className="flex-1 h-12 bg-[#B9FF66] hover:bg-[#a8e65a] text-black rounded-2xl font-bold text-sm"
                      >
                        {isSharing ? <Loader2 className="w-4 h-4 animate-spin" /> : "Invite Friends +"}
                      </Button>
                    </div>
                  </div>
                </TabsContent>
              </Tabs>
            </div>
          </div>
        </div>

      </main>


      {boosterPopupOpen && (
        <div className="fixed inset-0 bg-black/90 flex items-center justify-center z-50 px-4">
          <div className="bg-[#0d0d0d] rounded-2xl p-6 w-full max-w-sm border border-[#1a1a1a] relative">
            <div className="flex items-center justify-center gap-2 mb-6">
              <CalendarCheck className="w-5 h-5 text-[#4cd3ff]" />
              <h2 className="text-lg font-bold text-white">Daily Tasks</h2>
            </div>
            
            <div className="space-y-3 max-h-[60vh] overflow-y-auto pr-1 custom-scrollbar">
              <div className="flex items-center justify-between bg-[#1a1a1a] rounded-lg p-3 hover:bg-[#222] transition">
                <div className="flex-1 min-w-0">
                  <div className="flex items-center gap-2 mb-2">
                    <Users className="w-4 h-4 text-[#4cd3ff]" />
                    <p className="text-white text-sm font-medium truncate">Share with Friends</p>
                  </div>
                  <div className="text-xs text-gray-400 ml-6">
                    <p>Reward: <span className="text-white font-medium">{appSettings?.referralRewardHrum || '5'} Hrum</span></p>
                  </div>
                </div>
                <div className="ml-3 flex-shrink-0">
                  {missionStatus?.shareStory?.claimed ? (
                    <div className="h-8 w-20 rounded-lg bg-green-500/20 flex items-center justify-center">
                      <Check className="w-4 h-4 text-green-400" />
                    </div>
                  ) : shareWithFriendsStep === 'ready' || shareWithFriendsStep === 'claiming' ? (
                    <Button
                      onClick={handleClaimShareWithFriends}
                      disabled={shareWithFriendsMutation.isPending}
                      className="h-8 w-20 text-xs font-bold rounded-lg bg-green-500 hover:bg-green-600 text-white"
                    >
                      {shareWithFriendsMutation.isPending ? <Loader2 className="w-3 h-3 animate-spin" /> : 'Claim'}
                    </Button>
                  ) : (
                    <Button
                      onClick={handleShareWithFriends}
                      disabled={!referralLink}
                      className="h-8 w-16 text-xs font-bold rounded-lg bg-blue-500 hover:bg-blue-600 text-white"
                    >
                      Share
                    </Button>
                  )}
                </div>
              </div>

              <div className="flex items-center justify-between bg-[#1a1a1a] rounded-lg p-3 hover:bg-[#222] transition">
                <div className="flex-1 min-w-0">
                  <div className="flex items-center gap-2 mb-2">
                    <CalendarCheck className="w-4 h-4 text-[#4cd3ff]" />
                    <p className="text-white text-sm font-medium truncate">Daily Check-in</p>
                  </div>
                  <div className="text-xs text-gray-400 ml-6">
                    <p>Reward: <span className="text-white font-medium">{appSettings?.dailyCheckinReward || '5'} Hrum</span></p>
                  </div>
                </div>
                <div className="ml-3 flex-shrink-0">
                  {missionStatus?.dailyCheckin?.claimed ? (
                    <div className="h-8 w-20 rounded-lg bg-green-500/20 flex items-center justify-center">
                      <Check className="w-4 h-4 text-green-400" />
                    </div>
                  ) : dailyCheckinStep === 'ads' ? (
                    <Button
                      disabled={true}
                      className="h-8 w-20 text-xs font-bold rounded-lg bg-purple-600 text-white"
                    >
                      Watching...
                    </Button>
                  ) : dailyCheckinStep === 'ready' || dailyCheckinStep === 'claiming' ? (
                    <Button
                      onClick={handleClaimDailyCheckin}
                      disabled={dailyCheckinMutation.isPending}
                      className="h-8 w-20 text-xs font-bold rounded-lg bg-green-500 hover:bg-green-600 text-white"
                    >
                      {dailyCheckinMutation.isPending ? <Loader2 className="w-3 h-3 animate-spin" /> : 'Claim'}
                    </Button>
                  ) : (
                    <Button
                      onClick={handleDailyCheckin}
                      className="h-8 w-20 text-xs font-bold rounded-lg bg-[#4cd3ff] hover:bg-[#3db8e0] text-black"
                    >
                      Check-in
                    </Button>
                  )}
                </div>
              </div>

              <div className="flex items-center justify-between bg-[#1a1a1a] rounded-lg p-3 hover:bg-[#222] transition">
                <div className="flex-1 min-w-0">
                  <div className="flex items-center gap-2 mb-2">
                    <Rocket className="w-4 h-4 text-[#4cd3ff]" />
                    <p className="text-white text-sm font-medium truncate">Check for Updates</p>
                  </div>
                  <div className="text-xs text-gray-400 ml-6">
                    <p>Reward: <span className="text-white font-medium">{appSettings?.checkForUpdatesReward || '5'} Hrum</span></p>
                  </div>
                </div>
                <div className="ml-3 flex-shrink-0">
                  {missionStatus?.checkForUpdates?.claimed ? (
                    <div className="h-8 w-20 rounded-lg bg-green-500/20 flex items-center justify-center">
                      <Check className="w-4 h-4 text-green-400" />
                    </div>
                  ) : checkForUpdatesStep === 'opened' ? (
                    <div className="h-8 w-20 flex items-center justify-center gap-1 bg-[#1a1a1a] border border-[#4cd3ff]/30 rounded-lg">
                      <Clock size={12} className="text-[#4cd3ff]" />
                      <span className="text-white text-xs font-bold">{checkForUpdatesCountdown}s</span>
                    </div>
                  ) : checkForUpdatesStep === 'ready' || checkForUpdatesStep === 'claiming' ? (
                    <Button
                      onClick={handleClaimCheckForUpdates}
                      disabled={checkForUpdatesMutation.isPending}
                      className="h-8 w-20 text-xs font-bold rounded-lg bg-green-500 hover:bg-green-600 text-white"
                    >
                      {checkForUpdatesMutation.isPending ? <Loader2 className="w-3 h-3 animate-spin" /> : 'Claim'}
                    </Button>
                  ) : (
                    <Button
                      onClick={handleCheckForUpdates}
                      className="h-8 w-20 text-xs font-bold rounded-lg bg-orange-500 hover:bg-orange-600 text-white"
                    >
                      Open
                    </Button>
                  )}
                </div>
              </div>
            </div>

            <Button
              onClick={() => setBoosterPopupOpen(false)}
              className="w-full mt-6 bg-[#1a1a1a] hover:bg-[#222] text-white border border-[#333] rounded-xl"
            >
              Close
            </Button>
          </div>
        </div>
      )}

      {promoPopupOpen && (
        <div className="fixed inset-0 bg-black/90 flex items-center justify-center z-[60] px-4 backdrop-blur-sm">
          <motion.div 
            initial={{ opacity: 0, scale: 0.9, y: 20 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            className="bg-[#0d0d0d] rounded-[24px] p-6 w-full max-w-[320px] border border-white/5 relative shadow-2xl overflow-hidden"
          >
            <div className="relative z-10 pt-2">
              <h2 className="text-xl font-black text-white text-center mb-1 uppercase tracking-tight">Promo code</h2>
              <p className="text-[11px] text-zinc-400 text-center mb-4 font-bold leading-relaxed px-1">
                Enter your promo code below to claim special rewards!
              </p>

              <div className="space-y-2">
                <Input
                  type="text"
                  placeholder="Enter code"
                  value={promoCode}
                  onChange={(e) => setPromoCode(e.target.value)}
                  className="bg-white/5 border-white/10 h-12 rounded-[16px] text-white text-center font-black uppercase tracking-widest placeholder:text-zinc-600 text-sm"
                />
                
                <Button
                  onClick={() => promoCode.trim() && redeemPromoMutation.mutate(promoCode.trim())}
                  disabled={isApplyingPromo || !promoCode.trim()}
                  className="w-full h-12 bg-white hover:bg-zinc-200 text-black rounded-[16px] font-black text-sm transition-all active:scale-95 shadow-lg shadow-white/5"
                >
                  {isApplyingPromo ? (
                    <div className="flex items-center gap-2">
                      <Loader2 className="w-4 h-4 animate-spin" />
                      Applying...
                    </div>
                  ) : (
                    "REDEEM"
                  )}
                </Button>

                <div className="pt-3 border-t border-white/5 mt-2">
                  <p className="text-[9px] text-zinc-500 text-center mb-2 font-black uppercase tracking-wider opacity-60">
                    Join our telegram channel for more gift codes!
                  </p>
                  
                  <div className="flex gap-2">
                    <Button
                      variant="outline"
                      onClick={() => window.open("https://t.me/MoneyAdz", "_blank")}
                      className="flex-1 h-10 bg-white/5 border-white/10 hover:bg-white/10 text-white rounded-lg font-black text-[10px] uppercase tracking-wider gap-1"
                    >
                      <Send className="w-3.5 h-3.5" />
                      Join
                    </Button>
                    <Button
                      variant="outline"
                      onClick={() => setPromoPopupOpen(false)}
                      className="h-10 px-4 bg-white/5 border-white/10 hover:bg-white/10 text-white rounded-lg font-black text-[10px] uppercase tracking-wider"
                    >
                      Close
                    </Button>
                  </div>
                </div>
              </div>
            </div>
          </motion.div>
        </div>
      )}

      {convertPopupOpen && (
        <div className="fixed inset-0 bg-black/90 flex items-center justify-center z-[60] px-4 backdrop-blur-sm">
          <motion.div 
            initial={{ opacity: 0, scale: 0.9, y: 20 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            className="bg-[#0d0d0d] rounded-[24px] p-6 w-full max-w-[320px] border border-white/5 relative shadow-2xl overflow-hidden"
          >
            <div className="relative z-10 pt-2">
              <h2 className="text-xl font-black text-white text-center mb-1 uppercase tracking-tight">Exchange Hrum for TON</h2>
              <p className="text-[11px] text-zinc-400 text-center mb-4 font-bold leading-relaxed px-1">
                Convert your earned Hrum into TON cryptocurrency instantly.
              </p>

              <div className="space-y-3">
                <div className="space-y-1.5">
                  <Label className="text-[10px] font-black text-zinc-500 uppercase tracking-widest ml-1">Amount (Hrum):</Label>
                  <div className="relative">
                    <Input
                      type="number"
                      placeholder="0"
                      value={convertAmount}
                      onChange={(e) => setConvertAmount(e.target.value)}
                      className="bg-white/5 border-white/10 h-11 rounded-xl text-white pl-4 pr-10 font-black text-sm focus:ring-blue-500/20 focus:border-blue-500/50 transition-all"
                    />
                    <div className="absolute right-3 top-1/2 -translate-y-1/2">
                      <div className="w-6 h-6 rounded-full overflow-hidden border border-white/10">
                        <img 
                          src="/images/hrum-logo.jpg" 
                          alt="Hrum" 
                          className="w-full h-full object-cover scale-150"
                        />
                      </div>
                    </div>
                  </div>
                  <div className="flex justify-between items-center px-1">
                    <span className="text-[9px] font-bold text-zinc-600 uppercase">Bal: {parseFloat((user as User)?.balance || '0').toLocaleString()}</span>
                    <button 
                      onClick={() => setConvertAmount((user as User)?.balance || '0')}
                      className="text-[9px] font-black text-blue-500 uppercase hover:text-blue-400"
                    >
                      Max
                    </button>
                  </div>
                </div>

                <div className="space-y-1.5">
                  <Label className="text-[10px] font-black text-zinc-500 uppercase tracking-widest ml-1">To receive (TON):</Label>
                  <div className="relative">
                    <div className="bg-white/5 border border-white/10 text-white h-11 rounded-xl pl-4 pr-10 font-black text-sm flex items-center">
                      {(Number(convertAmount || 0) / 10000).toFixed(4)}
                    </div>
                    <div className="absolute right-3 top-1/2 -translate-y-1/2">
                      <div className="w-6 h-6 rounded-full overflow-hidden border border-white/10 flex items-center justify-center">
                        <img 
                          src="/images/ton.png" 
                          alt="TON" 
                          className="w-full h-full object-cover"
                        />
                      </div>
                    </div>
                  </div>
                </div>

                <div className="pt-2">
                  <Button
                    onClick={() => convertMutation.mutate({ amount: Number(convertAmount), convertTo: 'TON' })}
                    disabled={convertMutation.isPending || !convertAmount || Number(convertAmount) <= 0}
                    className="w-full h-11 bg-white hover:bg-zinc-200 text-black rounded-xl font-black text-xs uppercase tracking-widest transition-all shadow-lg shadow-white/5"
                  >
                    {convertMutation.isPending ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      "Swap Now"
                    )}
                  </Button>
                </div>

                <div className="pt-3 border-t border-white/5 mt-1">
                  <p className="text-[9px] text-zinc-500 text-center mb-2 font-black uppercase tracking-wider opacity-60">
                    Rate: 10,000 Hrum = 1 TON
                  </p>
                  <Button
                    variant="outline"
                    onClick={() => setConvertPopupOpen(false)}
                    className="w-full h-10 bg-white/5 border-white/10 hover:bg-white/10 text-white rounded-lg font-black text-[10px] uppercase tracking-wider"
                  >
                    Close
                  </Button>
                </div>
              </div>
            </div>
          </motion.div>
        </div>
      )}

      {settingsOpen && (
        <SettingsPopup 
          onClose={() => setSettingsOpen(false)} 
        />
      )}

      <WithdrawalPopup 
        open={withdrawPopupOpen}
        onOpenChange={setWithdrawPopupOpen}
        tonBalance={withdrawBalance}
      />
    </Layout>
  );
}
